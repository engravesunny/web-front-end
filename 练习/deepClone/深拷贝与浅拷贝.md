# 深拷贝与浅拷贝

## 浅拷贝

### 什么是浅拷贝

**浅拷贝**是指创建一个新对象，新对象的属性值是原对象属性值的引用。也就是说，新对象和原对象共享一个属性值，修改其中一个对象的属性会影响到另一个对象。

### 常见的想拷贝方式包括

- 使用`Object.assign`方法进行浅拷贝
  
  ```js
    const obj = { 
        a: 1,
        b: {
            c: 2
        }
    };
    const newObj = Object.assign({}, obj);
    obj.a = 10;
    console.log(newObj.a); // 1
    obj.b.c = 10;
    console.log(newObj.b.c); // 10 与原对象共享一个属性值
  ```

- 使用**展开运算符**进行浅拷贝
  
  ```js
  const obj = {
    a: 1,
    b: {
        c: 2
    }
  }
  const newObj = { ...obj };
  obj.a = 10;
  console.log(newObj.a); // 1
  obj.b.c = 10;
  console.log(newObj.b.c); // 10 与原对象共享一个属性值
  ```

- 另外还有`Array.prototype.concar()`,`Array.prototype.slice()`等方法是浅拷贝。

### 手写一个浅拷贝

```js
const shallowClone = (obj) => {
    const clneObj = new obj.constructor();
    for( let k in obj) {
        if( obj.hasOwnProperty(k) ){
            cloneObj[k] = obj[k];
        }
    }
    return cloneObj;
}
```

- `hasOwnProperty()`：检查该枚举值是否属于该对象，如果是继承过来的就去掉，如果是自身的则进行拷贝。

## 深拷贝

### 什么是深拷贝

深拷贝是指创建一个新对象，新对象的属性值与原对象的属性值完全独立，修改其中一个对象的属性不会影响到另一个对象。

### 常见的深拷贝方式包括

- 使用`JSON.parse(JSON.stringify())`方法进行深拷贝，但注意该方法有一些限制，例如无法拷贝函数、循环引用等
  
  ```js
  const obj = {
    a: 1,
    b: {
        c: 2
    }
  }
  const newObj = JSON.parse(JSON.stringify(obj));
  obj.b.c = 10;
  console.log(newObj.b.c); // 2
  ```

- 使用第三方库，如Lodash的`cloneDeep()`方法进行深拷贝
  
  ```js
  const obj = { 
    a: 1,
    b: {
        c: 2
    }
  }
  const newObj = _.cloneDeep(obj);

  obj.b.c = 10;
  console.log(newObj.b.c); // 2
  ```

- 另外还有jQuery中的`extend()`是深拷贝。

需要注意的是，深拷贝可能会导致性能上的开销，特别是对于复杂的对象结构。在选择拷贝方式时，需要根据具体需求和对象的复杂度来决定使用哪种方式。

### 手写一个深拷贝

```js
const deepClone = (obj) => {
    const cache = new WeakMap(); // 创建一个缓存解决循环引用的问题
    const _deepClone = (value) => {
        // 1. value是非引用型类型或者value为null||undefined 返回value
        if( typeof value !== 'object' || value == null ) return value;
        // 2. value是Date实例或者RegExp实例，直接新创建一个实例返回
        if( value instanceOf Date ) return new Date(value);
        if( value instanceOf RegExp ) return new RegExp(value);
        // 3. 查找缓存中是否存在，解决循环引用
        if( cache.has(value) ) return cache.get(value);
        // 特殊情况结束，开始拷贝
        const cloneObj = new value.constructor();
        // 拷贝存入cache
        cache.set(value, cloneObj);
        // 遍历属性进行拷贝
        for(let key in value) {
            // 判断是否为自有属性
            if(value.hasownProperty(key)) {
                cloneObj[key] = _deepClone(value[key]); // 递归拷贝，就是继续检查value[key]是不是引用类型，是的话在深入拷贝，直到出现特殊情况。
            }
        }
        return cloneObj;
    }
    return _deepClone(obj);

}
```

## 总结

- 赋值：引用地址的拷贝。修改赋值后的数据，不管是基本数据类型还是引用数据类型，都会影响到原数据。
- 浅拷贝：一层拷贝。在浅拷贝中，修改基本数据类型不会影响原有数据的基本数据类型，修改引用数据类型会影响原有的数据类型。
- 深拷贝：无限层级拷贝。在深拷贝中，修改基本数据类型和引用数据类型都不会影响原有的数据类型。
