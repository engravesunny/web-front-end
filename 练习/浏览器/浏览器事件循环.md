## JS异步理解

1. js是一门单线程的语言，因为他运行在浏览器的渲染主线程上，而渲染主线程只有一个
2. 而渲染主线程承担着巨大的任务，渲染页面，执行js，执行各种网络 I/O 计时器等的回调函数都在渲染主线程上执行
如果使用同步就极有可能造成渲染主线程的阻塞，从而导致消息队列中的很多其它任务无法执行。一方面导致繁忙的主线程白白消耗时间，另一方面给用户造成卡死的现象
3. 所以交给浏览器采用异步的方式避免，具体做法是，比如计时器，网络，I/O，事件监听等，主线程把这些任务交给其他线程去处理，自身立即结束任务的执行，转而去执行后续代码，当其他线程完成任务时，将回调函数包装成任务加入到消息队列的末尾等待主线程的执行

在这种模式下主线程将不会阻塞，从而最大限度的保证了单线程的流畅运行

## JS事件循环理解

事件循环又叫做消息循环（chrome源码中命名为message loop ，w3c标准是 event loop） 他是浏览器渲染主线程的工作方式

在chrome源码中 他会开启一个不会结束的for循环，每次循环去消息队列中取一个任务进行执行（没有任务的时候停止循环进入休眠状态），而其他线程只需要在合适的时候将任务加入到消息队列的末尾（唤醒渲染主线程去循环获取消息队列中的任务）

过去是将消息队列简单的分为宏任务队列和微任务队列，这种说法已经不能满足现如今复杂的浏览器环境取而代之的是一种更加灵活的方式

根据w3c官方的解释，每个任务具有不同的类型，同一类型的任务必须在同一队列，不同类型的任务可以在不同的队列，不同任务队列有着不同的优先级，在一次事件循环中，浏览器自行决定取哪一个队列的任务执行。但是浏览器必须有一个微任务队列，微任务队列具有更高的优先级，必须优先调度执行

## JS计时器能准确计时吗？为什么？

不能准确计时，原因：

- 1. 计算机硬件本身没有原子钟，不支持准确计时
- 2. 操作系统的计时函数本身有少量偏差， 而js的计时器最终调用的是操作系统的计时函数，也就携带了这些偏差
- 3. 按照w3c的标准，浏览器实现计时时，如果嵌套超过5层则会带有4毫秒的最短时间，这样在计时小于4毫秒时就会差生偏差
- 4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此有带来了偏差
