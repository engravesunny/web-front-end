# 从输入URL到页面显示发生了什么

## URL的输入到浏览器解析的一些列事件

大致有以下几个过程

- 1. DNS解析
- 2. 发起TCP链接
- 3. 发起HTPP请求
- 4. 服务器处理请求并返回HTTP报文
- 5. 浏览器解析渲染页面
- 6. 连接结束

## DNS解析

DNS解析实际上就是寻找你所需要的资源的过程。假设你输入了`www.baidu.com`，而这个网址不是百度的真是网址，互联网中的每一台机器都有其唯一标识的IP地址，但IP地址有时会非常复杂，不方便记忆，所以就需要一个网址（域名）与IP地址的转换，而DNS解析就是解析网址为IP地址的过程，下面来具体了解一下解析的过程。

### 具体解析

#### 什么是DNS

DNS即域名系统，全称是**D**omain **N**ame **S**ystem。当我们在浏览器中输入一个URL是，浏览器要想向这个URL域名对应的服务器发送请求，就要得知这个服务器的IP地址，对于浏览器来说，DNS的作用就是将这个**域名转换为IP地址**。
下面是摘自《计算机网络：自顶向下方法》的概念：
> DNS是：
> 一个由分层的DNS服务器实现的分布式数据库
> 一个是主机能够查询分布式数据库的应用层协议

也就是，DNS 是一个应用层协议，我们发送一个请求，其中包含我们要查询的主机名，它就会给我们返回这个主机名对应的 IP；

其次，DNS 是一个分布式数据库，整个 DNS 系统由分散在世界各地的很多台 DNS 服务器组成，每台 DNS 服务器上都保存了一些数据，这些数据可以让我们最终查到主机名对应的 IP。

**所以 DNS 的查询过程，说白了，就是去向这些 DNS 服务器询问，你知道这个主机名的 IP 是多少吗，不知道？那你知道去哪台 DNS 服务器上可以查到吗？直到查到我想要的 IP 为止。**

#### DNS服务器

![DNS服务器](https://www.kecat.top/other/DNS服务器.webp)

- 根 DNS 服务器

首先我们要明确根域名是什么，比如 `www.baidu.com`，有些同学可能会误以为 com 就是根域名，其实 com 是顶级域名，www.baidu.com 的完整写法是 `www.baidu.com.`，最后的这个`.` 就是根域名。
根 DNS 服务器的作用是什么呢？就是管理它的下一级，也就是顶级域 DNS 服务器。通过询问根 DNS 服务器，我们可以知道一个主机名对应的顶级域 DNS 服务器的 IP 是多少，从而继续向顶级域 DNS 服务器发起查询请求。

- 顶级域 DNS 服务器

除了前面提到的 com 是顶级域名，常见的顶级域名还有 cn、org、edu 等。顶级域 DNS 服务器，也就是 TLD，提供了它的下一级，也就是权威 DNS 服务器的 IP 地址。

- 权威 DNS 服务器

权威 DNS 服务器可以返回主机 - IP 的最终映射。

#### 本地DNS服务器

之前对 DNS 有过了解的同学可能会发现，上一节的 DNS 层次结构，为什么没有提到本地 DNS 服务器？因为严格来说，本地 DNS 服务器并不属于 DNS 的层次结构，但它对 DNS 层次结构是至关重要的。那什么是本地 DNS 服务器呢？

每个 ISP 都有一台本地 DNS 服务器，比如一个居民区的 ISP、一个大学的 ISP、一个机构的 ISP，都有一台或多台本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，本地 DNS 服务器起着代理的作用，并负责将该请求转发到 DNS 服务器层次结构中。

接下来就让我们通过一个简单的例子，看看 DNS 的查询过程是怎样的，看看客户端、本地 DNS 服务器、DNS 服务器层次结构之间是如何交互的。

#### 递归查询、迭代查询

如下图，假设主机m.n.com 向获取主机a.b.com 的IP地址,会经过下面几个步骤：

![DNS递归迭代](https://www.kecat.top/other/DNS递归迭代.webp)

1. 首先，主机m.n.com本地DNS服务器发送一个DNS请求报文，如果本地域名有目标a.b.com的记录，就返回目标的IP地址给主机，如果没有本地DNS服务器就将它发送给根DNS服务器
2. 根DNS服务器会注意到com前缀，便向本地域名服务器返回com对应的顶级域名服务器的IP地址列表。意思就是，我不知道a.b.com的IP，不过这些TLD服务器可能知道，你去问他们吧
3. 本地域名服务器向其中一台TLD服务器发送查询报文
4. 该TLD服务器注意到b.com前缀，便向本地DNS服务器返回权威DNS服务器的IP地址。意思就是，我不知道a.b.com的IP，但这些权威DNS服务器可能知道，你去问他们吧（有时 TLD 只是知道中间的某个 DNS 服务器，再由这个中间 DNS 服务器去找到权威 DNS 服务器。这种时候，整个查询过程就需要更多的 DNS 报文。）
5. 本地域名服务器向其中一台权威域名服务器发送DNS查询报文。
6. 终于该权威DNS服务器返回了a.b.com的IP地址。
7. 本地 DNS 服务器将 a.b.com 跟 IP 地址的映射返回给主机 m.n.com，m.n.com 就可以用该 IP 向 a.b.com 发送请求啦。

#### 递归查询

一、递归查询:主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。

简单说 就是说我们请求的地址 必须返回一个准确的ip地址，没有就向别的地址查询，然后返回给我们一个准确的ip地址。我们的本地服务器就是递归服务器。

#### 迭代查询

二、迭代查询:本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。

这里由各级服务器进行的就是迭代查询，自身不返回ip，而是返回给下一级的DNS服务器地址。
实际一般本地DNS访问量巨大，会有一个前置的F5服务器，用于分发给后缀的服务器实现负载均衡。同时服务器会根据设置会缓存一段时间地址。所以有时候我们在服务器改完DNS，有时候会等一段时间，才能访问到新的地址。

### DNS缓存

为了让我们更快的拿到想要的 IP，DNS 广泛使用了缓存技术。DNS 缓存的原理非常简单，在一个 DNS 查询的过程中，当某一台 DNS 服务器接收到一个 DNS 应答（例如，包含某主机名到 IP 地址的映射）时，它就能够将映射缓存到本地，下次查询就可以直接用缓存里的内容。当然，缓存并不是永久的，每一条映射记录都有一个对应的生存时间，一旦过了生存时间，这条记录就应该从缓存移出。
事实上，有了缓存，大多数 DNS 查询都绕过了根 DNS 服务器，需要向根 DNS 服务器发起查询的请求很少。

### DNS负载均衡

不知道你们有没有注意这样一件事，你访问baidu.com的时候，每次响应的并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，假设只有一个服务器，那它的性能和存储量要多大才能支撑这样大量的访问呢？DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡

## 发起TCP连接

这里要提醒一点，Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请
求就得等待。
假设现在不需要等待，我们进入了 TCP 连接的建立阶段。首先解释一下什么是 TCP

> TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

### TCP头部字段分析

![tcp头部](https://www.kecat.top/other/tcp头部.png)

TCP首部承载这TCP协议需要的各项信息，下面我们来分析一下：

- TCP端口号

TCP的连接是需要四个要素确定唯一一个连接：

（源IP，源端口号）+ （目地IP，目的端口号）所以TCP首部预留了两个16位作为端口号的存储，而IP地址由上一层IP协议负责传递源端口号和目地端口各占16位两个字节，也就是端口的范围是2^16=65535另外1024以下是系统保留的，从1024-65535是用户使用的端口范围

- TCP的序号和确认号：
  
32位序号 seq：Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据有序，比如现在序列号为1000，发送了1000，下一个序列号就是2000。32位确认号 ack：Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。

- TCP的标志位
  
每个TCP段都有一个目的，这是借助于TCP标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。用的最广泛的标志是 SYN，ACK 和 FIN，用于建立连接，确认成功的段传输，最后终止连接。

- SYN：简写为S，同步标志位，用于建立会话连接，同步序列号；
- ACK： 简写为.，确认标志位，对已接收的数据包进行确认；
- FIN： 简写为F，完成标志位，表示我已经没有数据要发送了，即将关闭连接；
- PSH：简写为P，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
- RST：简写为R，重置标志位，用于连接复位、拒绝错误和非法的数据包；
- URG：简写为U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；

建立 TCP连接 经历了下面三个阶段:

- 1）通过三次握手(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。
- 2）进行数据传输。这里有一个重要的机制，就是接收方接收到数据包后必须要向发送方 确认 , 如果发送
方没有接到这个 确认 的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一
个优化策略，就是把 大的数据包拆成一个个小包 ，依次传输到接收方，接收方按照这个小包的顺序把它们
组装 成完整数据包。
- 3）断开连接的阶段。数据传输完成，现在要断开连接了，通过四次挥手来断开连接。

### 三次握手

![三次握手](https://www.kecat.top/other/三次握手.png)

- 第一次握手

客户端将TCP报文标志位SYN置为1，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入SYN_SENT状态，等待服务器端确认。

- 第二次握手

服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。

- 第三次握手

客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

注意:我们上面写的ack和ACK，不是同一个概念：

- 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。
- 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。

### 为什么采用三次握手，若采用二次握手可以吗？四次呢？

我们假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。
本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。
所以，采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

采用两次握手不行，原因就是上面说的失效的连接请求的特殊情况。而在三次握手中， client和server都有一个发syn和收ack的过程， 双方都是发后能收， 表明通信则准备工作OK.

为什么不是四次握手呢？ 大家应该知道通信中著名的蓝军红军约定， 这个例子说明， 通信不可能100%可靠， 而上面的三次握手已经做好了通信的准备工作， 再增加握手， 并不能显著提高可靠性， 而且也没有必要。

### 四次挥手

![四次挥手](https://www.kecat.top/other/四次挥手.webp)

- 第一次挥手：
客户端发送一个FIN，用来关闭客户端到服务器的数据传送，也就是客户端告诉服务器：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据)，但是，此时客户端还可 以接受数据。
FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- 第二次挥手：
服务器收到FIN包后，发送一个ACK给对方并且带上自己的序列号seq，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
- 第三次挥手：
服务器发送一个FIN，用来关闭服务器到客户端的数据传送，也就是告诉客户端，我的数据也发送完了，不会再给你发数据了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：
主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
至此，完成四次挥手。

### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。
由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

### 为什么要等待2MSL？

- MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。有以下两个原因：

- **第一点：保证TCP协议的全双工连接能够可靠关闭：**

由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于CLOESD状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入CLOSED状态，而要保持TIME_WAIT，当再次收到FIN的收，能够保证对方收到ACK，最后正确关闭连接。

- **第二点：保证这次连接的重复数据段从网络中消失**

如果Client端发送最后的ACK直接进入CLOSED状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。

## 发送HTTP请求

### 常见的请求方法区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。

#### 重点区别

GET会产生一个TCP数据包，而POST会产生两个TCP数据包。
详细的说就是：

- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);

- 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。-

#### 请求正文

当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。

#### HTTP缓存

这个以参考另一篇文章[HTTP缓存](https://kecat.top/article?postName=HTTP%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF&date=2023-08-27+13:36:02&tag=HTTP&category=%E7%AC%94%E8%AE%B0)

### 不同刷新的请求执行过程

#### 浏览器地址栏中写入URL，回车

- 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）

#### F5

- F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就战战兢兢的发送一个请求带上If-Modify-since。

#### Ctrl+F5

- 告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作.

### 服务器处理请求并返回HTTP报文

它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Nginx和Apache等等
HTTP报文也分成三份，状态码 ，响应报头和响应报文

关于http状态码可以参考[HTTP常见状态码](https://kecat.top/article?postName=HTTP%E7%8A%B6%E6%80%81%E7%A0%81&date=2023-08-27+13:34:24&tag=HTTP&category=%E7%AC%94%E8%AE%B0)
